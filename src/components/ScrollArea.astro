---
export interface Props {
	class?: string;
	style?: string;
	dir?: "ltr" | "rtl";
	scrollHideDelay?: number;
	hideScrollbar?: boolean;
	viewportClass?: string;
	viewportStyle?: string;
	scrollbarClass?: string;
	scrollbarStyle?: string;
	thumbClass?: string;
	thumbStyle?: string;
	id?: string;
}

const {
	class: className = "",
	style = "",
	dir = "ltr",
	scrollHideDelay = 600,
	hideScrollbar = false,
	viewportClass = "",
	viewportStyle = "",
	scrollbarClass = "",
	scrollbarStyle = "",
	thumbClass = "",
	thumbStyle = "",
	id,
} = Astro.props;

const uniqueId = id || Math.random().toString(36).substring(2, 9);
---

<div
	class={`scroll-area ${className}`}
	style={style}
	dir={dir}
	data-scroll-area-id={uniqueId}
	data-scroll-hide-delay={scrollHideDelay}
	data-hide-scrollbar={hideScrollbar}
>
	<div
		class={`scroll-area-viewport ${viewportClass}`}
		style={viewportStyle}
		data-viewport-id={uniqueId}
	>
		<div class="scroll-area-content">
			<slot />
		</div>
	</div>

	{
		!hideScrollbar && (
			<>
				<div
					class={`scroll-area-scrollbar scroll-area-scrollbar-y ${scrollbarClass}`}
					style={scrollbarStyle}
					data-scrollbar-id={uniqueId}
					data-orientation="vertical"
					role="scrollbar"
					aria-orientation="vertical"
					aria-controls={`viewport-${uniqueId}`}
				>
					<div
						class={`scroll-area-thumb ${thumbClass}`}
						style={thumbStyle}
						data-thumb-id={uniqueId}
					/>
				</div>

				<div
					class={`scroll-area-scrollbar scroll-area-scrollbar-x ${scrollbarClass}`}
					style={scrollbarStyle}
					data-scrollbar-id={uniqueId}
					data-orientation="horizontal"
					role="scrollbar"
					aria-orientation="horizontal"
					aria-controls={`viewport-${uniqueId}`}
				>
					<div
						class={`scroll-area-thumb ${thumbClass}`}
						style={thumbStyle}
						data-thumb-id={uniqueId}
					/>
				</div>
			</>
		)
	}
</div>

<style>
	.scroll-area {
		position: relative;
		overflow: hidden;
	}

	.scroll-area-viewport {
		width: 100%;
		height: 100%;
		overflow: auto;
		scrollbar-width: none;
		-ms-overflow-style: none;
		-webkit-overflow-scrolling: touch;
	}

	.scroll-area-viewport::-webkit-scrollbar {
		display: none;
	}

	.scroll-area-content {
		min-width: 100%;
		display: table;
	}

	.scroll-area-scrollbar {
		position: absolute;
		background: transparent;
		opacity: 0;
		transition: opacity 0.2s ease;
		pointer-events: none;
	}

	.scroll-area:hover .scroll-area-scrollbar {
		opacity: 1;
		pointer-events: auto;
	}

	.scroll-area-scrollbar-y {
		top: 2px;
		right: 2px;
		bottom: 2px;
	}

	.scroll-area-scrollbar-x {
		left: 2px;
		right: 2px;
		bottom: 2px;
	}

	[dir="rtl"] .scroll-area-scrollbar-y {
		right: auto;
		left: 2px;
	}

	.scroll-area-thumb {
		background: var(--color-base-700);
		border-radius: 0;
		min-width: 8px;
		min-height: 8px;
		position: relative;
	}

	.scroll-area-scrollbar-y .scroll-area-thumb {
		width: 4px;
		transform: translateY(0);
		margin: 1px 0;
	}

	.scroll-area-scrollbar-x .scroll-area-thumb {
		height: 4px;
		transform: translateX(0);
		margin: 0 1px;
	}

	.scroll-area-scrollbar[data-state="hidden"] {
		opacity: 0;
		pointer-events: none;
	}

	.scroll-area-scrollbar[data-state="visible"] {
		opacity: 1;
		pointer-events: auto;
	}
</style>

<script>
	class ScrollArea {
		private element: HTMLElement;
		private viewport: HTMLElement;
		private scrollbarY: HTMLElement | null;
		private scrollbarX: HTMLElement | null;
		private thumbY: HTMLElement | null;
		private thumbX: HTMLElement | null;
		private hideDelay: number;
		private hideScrollbar: boolean;

		private isDragging: boolean;
		private dragStartPos: { x: number; y: number };
		private dragStartScroll: { x: number; y: number };
		private hideTimer: number | null;

		constructor(element: HTMLElement) {
			this.element = element;
			this.viewport = element.querySelector(
				".scroll-area-viewport",
			) as HTMLElement;
			this.scrollbarY = element.querySelector(
				".scroll-area-scrollbar-y",
			) as HTMLElement | null;
			this.scrollbarX = element.querySelector(
				".scroll-area-scrollbar-x",
			) as HTMLElement | null;
			this.thumbY = element.querySelector(
				".scroll-area-scrollbar-y .scroll-area-thumb",
			) as HTMLElement | null;
			this.thumbX = element.querySelector(
				".scroll-area-scrollbar-x .scroll-area-thumb",
			) as HTMLElement | null;
			this.hideDelay = parseInt(element.dataset.scrollHideDelay || "600");
			this.hideScrollbar = element.dataset.hideScrollbar === "true";

			this.isDragging = false;
			this.dragStartPos = { x: 0, y: 0 };
			this.dragStartScroll = { x: 0, y: 0 };
			this.hideTimer = null;

			this.init();
		}

		init(): void {
			if (this.hideScrollbar) return;

			this.updateScrollbars();
			this.bindEvents();
			this.setupResizeObserver();
		}

		bindEvents(): void {
			// Viewport scroll events
			this.viewport.addEventListener("scroll", () => {
				this.updateThumbPositions();
				this.showScrollbars();
			});

			// Mouse enter/leave for hover behavior
			this.element.addEventListener("mouseenter", () => {
				this.showScrollbars();
			});

			this.element.addEventListener("mouseleave", () => {
				this.hideScrollbars();
			});

			// Scrollbar interactions
			if (this.scrollbarY) {
				this.scrollbarY.addEventListener("pointerdown", (e: PointerEvent) =>
					this.handleScrollbarPointerDown(e, "y"),
				);
				this.scrollbarY.addEventListener("wheel", (e: WheelEvent) =>
					this.handleScrollbarWheel(e, "y"),
				);
			}

			if (this.scrollbarX) {
				this.scrollbarX.addEventListener("pointerdown", (e: PointerEvent) =>
					this.handleScrollbarPointerDown(e, "x"),
				);
				this.scrollbarX.addEventListener("wheel", (e: WheelEvent) =>
					this.handleScrollbarWheel(e, "x"),
				);
			}

			// Global pointer events for dragging
			document.addEventListener("pointermove", (e: PointerEvent) =>
				this.handlePointerMove(e),
			);
			document.addEventListener("pointerup", () => this.handlePointerUp());
		}

		setupResizeObserver(): void {
			if (!window.ResizeObserver) return;

			const resizeObserver = new ResizeObserver(() => {
				this.updateScrollbars();
			});

			resizeObserver.observe(this.viewport);
			if (this.viewport.firstElementChild) {
				resizeObserver.observe(this.viewport.firstElementChild);
			}
		}

		updateScrollbars(): void {
			const contentRect =
				this.viewport.firstElementChild?.getBoundingClientRect();
			const viewportRect = this.viewport.getBoundingClientRect();

			if (!contentRect) return;

			const hasVerticalScroll = contentRect.height > viewportRect.height;
			const hasHorizontalScroll = contentRect.width > viewportRect.width;

			if (this.scrollbarY) {
				this.scrollbarY.style.display = hasVerticalScroll ? "block" : "none";
				this.updateThumbSize("y");
			}

			if (this.scrollbarX) {
				this.scrollbarX.style.display = hasHorizontalScroll ? "block" : "none";
				this.updateThumbSize("x");
			}
		}

		updateThumbSize(orientation: "x" | "y"): void {
			const viewport = this.viewport;
			const scrollbar = orientation === "y" ? this.scrollbarY : this.scrollbarX;
			const thumb = orientation === "y" ? this.thumbY : this.thumbX;

			if (!scrollbar || !thumb) return;

			const isVertical = orientation === "y";
			const viewportSize = isVertical
				? viewport.offsetHeight
				: viewport.offsetWidth;
			const contentSize = isVertical
				? viewport.scrollHeight
				: viewport.scrollWidth;
			const scrollbarSize = isVertical
				? scrollbar.offsetHeight
				: scrollbar.offsetWidth;

			const ratio = viewportSize / contentSize;
			const thumbSize = Math.max(scrollbarSize * ratio, 18);

			if (isVertical) {
				thumb.style.height = `${thumbSize}px`;
			} else {
				thumb.style.width = `${thumbSize}px`;
			}
		}

		updateThumbPositions(): void {
			if (this.thumbY && this.scrollbarY) {
				const scrollTop = this.viewport.scrollTop;
				const maxScrollTop =
					this.viewport.scrollHeight - this.viewport.offsetHeight;
				const scrollbarHeight = this.scrollbarY.offsetHeight;
				const thumbHeight = this.thumbY.offsetHeight;
				const margin = 2; // 1px top + 1px bottom
				const maxThumbTop = scrollbarHeight - thumbHeight - margin;
				const thumbTop =
					maxScrollTop > 0 ? (scrollTop / maxScrollTop) * maxThumbTop : 0;
				this.thumbY.style.transform = `translateY(${thumbTop}px)`;
			}

			if (this.thumbX && this.scrollbarX) {
				const scrollLeft = this.viewport.scrollLeft;
				const maxScrollLeft =
					this.viewport.scrollWidth - this.viewport.offsetWidth;
				const scrollbarWidth = this.scrollbarX.offsetWidth;
				const thumbWidth = this.thumbX.offsetWidth;
				const margin = 2; // 1px left + 1px right
				const maxThumbLeft = scrollbarWidth - thumbWidth - margin;
				const thumbLeft =
					maxScrollLeft > 0 ? (scrollLeft / maxScrollLeft) * maxThumbLeft : 0;
				this.thumbX.style.transform = `translateX(${thumbLeft}px)`;
			}
		}

		handleScrollbarPointerDown(e: PointerEvent, orientation: "x" | "y"): void {
			e.preventDefault();
			this.isDragging = true;
			this.dragStartPos = { x: e.clientX, y: e.clientY };
			this.dragStartScroll = {
				x: this.viewport.scrollLeft,
				y: this.viewport.scrollTop,
			};

			const scrollbar = orientation === "y" ? this.scrollbarY : this.scrollbarX;
			if (scrollbar) {
				scrollbar.setPointerCapture(e.pointerId);
			}
		}

		handlePointerMove(e: PointerEvent): void {
			if (!this.isDragging) return;

			const deltaX = e.clientX - this.dragStartPos.x;
			const deltaY = e.clientY - this.dragStartPos.y;

			const scrollbarY = this.scrollbarY;
			const scrollbarX = this.scrollbarX;

			if (scrollbarY && this.thumbY && Math.abs(deltaY) > Math.abs(deltaX)) {
				const scrollbarHeight =
					scrollbarY.offsetHeight - this.thumbY.offsetHeight;
				const maxScrollTop =
					this.viewport.scrollHeight - this.viewport.offsetHeight;
				const scrollRatio = deltaY / scrollbarHeight;
				const newScrollTop =
					this.dragStartScroll.y + scrollRatio * maxScrollTop;
				this.viewport.scrollTop = Math.max(
					0,
					Math.min(maxScrollTop, newScrollTop),
				);
			}

			if (scrollbarX && this.thumbX && Math.abs(deltaX) > Math.abs(deltaY)) {
				const scrollbarWidth = scrollbarX.offsetWidth - this.thumbX.offsetWidth;
				const maxScrollLeft =
					this.viewport.scrollWidth - this.viewport.offsetWidth;
				const scrollRatio = deltaX / scrollbarWidth;
				const newScrollLeft =
					this.dragStartScroll.x + scrollRatio * maxScrollLeft;
				this.viewport.scrollLeft = Math.max(
					0,
					Math.min(maxScrollLeft, newScrollLeft),
				);
			}
		}

		handlePointerUp(): void {
			if (this.isDragging) {
				this.isDragging = false;
				if (this.scrollbarY) this.scrollbarY.releasePointerCapture(0);
				if (this.scrollbarX) this.scrollbarX.releasePointerCapture(0);
			}
		}

		handleScrollbarWheel(e: WheelEvent, orientation: "x" | "y"): void {
			e.preventDefault();
			const isVertical = orientation === "y";
			const delta = isVertical ? e.deltaY : e.deltaX;
			const currentScroll = isVertical
				? this.viewport.scrollTop
				: this.viewport.scrollLeft;
			this.viewport[isVertical ? "scrollTop" : "scrollLeft"] =
				currentScroll + delta;
		}

		showScrollbars(): void {
			if (this.hideTimer) {
				clearTimeout(this.hideTimer);
				this.hideTimer = null;
			}

			if (this.scrollbarY)
				this.scrollbarY.setAttribute("data-state", "visible");
			if (this.scrollbarX)
				this.scrollbarX.setAttribute("data-state", "visible");
		}

		hideScrollbars(): void {
			this.hideTimer = window.setTimeout(() => {
				if (this.scrollbarY)
					this.scrollbarY.setAttribute("data-state", "hidden");
				if (this.scrollbarX)
					this.scrollbarX.setAttribute("data-state", "hidden");
			}, this.hideDelay);
		}
	}

	// Track initialized scroll areas to prevent duplicates
	const initializedScrollAreas = new WeakSet();

	function initScrollAreas(): void {
		const scrollAreas = document.querySelectorAll("[data-scroll-area-id]");
		scrollAreas.forEach((element) => {
			// Check if this element has already been initialized
			if (!initializedScrollAreas.has(element)) {
				initializedScrollAreas.add(element);
				new ScrollArea(element as HTMLElement);
			}
		});
	}

	// Initialize scroll areas when the DOM is ready
	if (document.readyState === "loading") {
		document.addEventListener("DOMContentLoaded", () => {
			// Small delay to ensure Astro components are fully rendered
			setTimeout(initScrollAreas, 0);
		});
	} else {
		// If DOM is already loaded, initialize with a small delay
		setTimeout(initScrollAreas, 0);
	}

	// Also initialize on Astro page transitions (if using View Transitions)
	document.addEventListener("astro:page-load", initScrollAreas);
	
	// Handle View Transitions API if available
	if (document.startViewTransition) {
		document.addEventListener("astro:after-swap", initScrollAreas);
	}
</script>
